### chap4. 제어 유니트

------

 적절한 제어 신호들을 생성시키는 제어 유니트에 대해 알아본다.

#### 4.1 제어 유니트의 기능

 제어 유니트의 주요 기능은 다음과 같다.

- 명령어 코드의 해독
- 명령어 실행에 필요한 제어 신호들의 발생

 즉, 제어 유니트는 명령어 사이클이 적절히 수행되도록 모든 동작들을 제어하는 장치이다. 

- 마이크로명령어: 마이크로연산을 2진 비트로 표현한 형태
- 마이크로프로그램: 마이크로명령어의 집합
- 루틴: CPU의 특정 기능을 수행하기 위한 마이크로프로그램

 명령어 사이클을 위한 마이크로프로그램은 인출 사이클 루틴, 간접 사이클 루틴, 실행 사이클 루틴들로 구성된다.



#### 4.2 제어 유니트의 구조

 제어 유니트의 내부 구조는 다음과 같다.

![](img/ch4_1.jpg)

- 명령어 해독기: 명령어 레지스터로부터 들어오는 명령어의 연산 코드를 해독하여 해당 연산을 수행하기 위한 루틴의 시작 주소를 결정
- 제어 주소 레지스터(CAR): 다음에 실행할 마이크로명령어의 주소를 저장하는 레지스터이다. 이 주소는 제어 기억장치의 특정 위치를 가리킨다.
- 제어 기억장치: 마이크로프로그램을 저장하는 내부 기억장치
- 제어 버퍼 레지스터(CBR): 제어 기억장치로부터 읽혀진 마이크로명령어를 일시적으로 저장하는 레지스터
- 서브 루틴 레지스터(SBR): 마이크로프로그램에서 서브루틴이 호출되는 경우, 현재의 CAR 내용을 일시적으로 저장하는 레지스터
- 순서제어 모듈: 마이크로명령어의 실행 순서를 결정하는 회로들의 집합



 CPU 명령어 세트를 설계한다는 것은

1. 명령어들의 종류와 비트 패턴을 정의
2. 그 명령어들의 실행에 필요한 하드웨어를 설계하며
3. 각 명령어를 위한 실행 사이클 루틴을 마이크로프로그래밍함

를 의미한다. 마이크로프로그램은 그러한 루틴들의 집합이므로 CPU 설계 단계에서 확정되고, 그 후에는 변하지 않는다. 따라서 제어 기억장치는 ROM으로 만들어져 CPU 내부에 포함된다.

 명령어 해독기는 연산 코드를 이용하여 제어 기억장치 내 해당 실행 사이클 루틴의 시작 주소를 찾아야 한다. 그 방법에는 몇 가지가 있으나, 그 중 사상(mapping)에 대해 설명한다.



 사상 방식은 명령어의 연산 코드를 특정 비트 패턴과 혼합시켜 그 연산의 수행에 필요한 실행 사이클 루틴의 시작주소를 찾아낸다. **시작 주소: 1xxxx00**

![](img/ch4_2.jpg)



#### 4.3 마이크로명령어의 형식

 ![](img/ch4_3.jpg)

- 연산필드가 여러 개일 경우 그 수 만큼의 마이크로 연산들이 동시에 수행될 수 있다.
- 조건 필드는 두 비트로 구성되며 다음에 위치한 분기 필드를 위한 조건을 나타낸다.
- 분기 필드는 두 비트로 구성되며 분기의 종류와 다음에 어떤 마이크로명령어를 실행할 지를 결정한다.
- 주소 필드는 분기가 발생하는 경우를 위해 목적지 마이크로명령어의 주소를 가지고 있다.

#### 4.4 마이크로프로그래밍

**4.4.1 인출 사이클 루틴**

|             |      |      |      |                             |
| ----------- | ---- | ---- | ---- | --------------------------- |
| FETCH:PCTAR | U    | JMP  | NEXT | MAR <- PC                   |
| READ, INCPC | U    | JMP  | NEXT | MBR <- M[MAR], PC <- PC + 1 |
| BRTIR       | U    | MAP  |      | IR <- MBR                   |

**4.4.2 간접 사이클 루틴**: i bit 가 1로 세트된다.

|             |      |      |      |                             |
| ----------- | ---- | ---- | ---- | --------------------------- |
| INDRT:IRTAR | U    | JMP  | NEXT | MAR <- IR(addr)             |
| READ        | U    | JMP  | NEXT | MBR <- M[MAR], PC <- PC + 1 |
| BRTIR       | U    | RET  |      | IR(addr) <- MBR             |

**4.4.3 실행 사이클 루틴**

 사상 방식을 이용하여 각 루틴의 시작 주소를 결정한다. 명령어는 NOP, LOAD, STORE(I), ADD, SUB, JUMP 등이 있으며 예제는 다음과 같다.

|        |       |      |      |       |                       |
| ------ | ----- | ---- | ---- | ----- | --------------------- |
| NOP:   | INCPC | U    | JMP  | FETCH | PC <- PC + 1          |
| LOAD:  | NOP   | I    | CALL | INDRT | I = 1이면, 4.4.2 호출 |
|        | READ  | U    | JMP  | NEXT  | MAR <- IR(addr)       |
|        | BRTAC | U    | JMP  | FETCH | AC <- MBR             |
| STORE: | NOP   | I    | CALL | INDRT | I = 1이면, 4.4.2 호출 |
|        | IRTAR | U    | JMP  | NEXT  | MAR <- IR(addr)       |
|        | ACTBR | U    | JMP  | NEXT  | MBR <- AC             |
|        | WRITE | U    | JMP  | FETCH | M[MAR] <- MBR         |
| ADD:   | IRTAR | U    | JMP  | NEXT  | MAR <- IR(addr)       |
|        | READ  | U    | JMP  | NEXT  | MBR <- M[MAR]         |
|        | ADD   | U    | JMP  | FETCH | AC <- AC + MBR        |
| SUB:   | IRTAR | U    | JMP  | NEXT  | MAR <- IR(addr)       |
|        | READ  | U    | JMP  | NEXT  | MBR <- M[MAR]         |
|        | SUB   | U    | JMP  | FETCH | AC <- AC - MBR        |
| JUMP:  | IRTPC | U    | JMP  | FETCH | PC <- IR(addr)        |



#### 4.5 마이크로프로그램의 순서제어

 제어 유니트가 명령어의 실행을 제어한다는 것은 제어 기억장치에 저장된 해당 마이크로명령어들을 순서대로 인출하는 동작이라고 할 수 있다.

![](img/ch4_4.jpg)

- 순서제어: 제어 유니트에서 다음에 실행될 마이크로 명령어의 주소를 결정하는 기능





CPU가 처음 동작을 시작하는 순간: CAR <- 0, 0번지에 있는 인출 사이클 루틴의 첫 번째 마이크로 명령어를 인출

MUX2: 네 개의 조건 비트중 하나를 선택 

MUX1: BR필드의 두 비트와 MUX2의 출력비트의 조합으로 MUX1의 선택신호들과 SBR의 적재신호가 생성, 그에 따라 다음 주소들이 결정되어 CAR로 적재된다.

주소 선택 회로의 입력 및 출력 신호들:

| BR    | 조건 | MUX1  | SBR  | CAR로 적재될 MUX1의 입력 |           설명           |
| ----- | ---- | ----- | ---- | :----------------------: | :----------------------: |
| I1 I0 | C    | S1 S0 | L    |            -             |            -             |
| 0  0  | 0    | 0  0  | 0    |            0             |      CAR <-CAR + 1       |
| 0  0  | 1    | 0  1  | 0    |            1             |      CAR<-ADF<JUMP>      |
| 0  1  | 0    | 0  0  | 0    |            0             |        CAR<-CAR+1        |
| 0  1  | 1    | 0  1  | 1    |            1             | SBR<-CAR ,CAR<-ADF<CALL> |
| 1  0  | x    | 1  0  | 0    |            2             |         CAR<-SBR         |
| 1  1  | x    | 1  1  | 0    |            3             |       CAR<-1XXXX00       |



BR필드가 00 또는 01일 경우: 조건이 만족되지 않으면 (C가 0이면) CAR<-CAR+1

​						   조건이 만족 되면(C가 1이면) CAR<-ADF

BR필드가 10인 경우: SBR이 다시 CAR로 복구

BR필드가 11인 경우: Mapping에 의해 결정된 주소가 CAR로 적재



만약 마이크로 연산을 수행하는데 더 많은 제어 신호들이 필요하다면 decoder들을 이용해 그 수를 확대할 수 있다.



- 수직적 마이크로프로그래밍: decoder들을 적극 활용하여 비트들을 필요한 수만큼의 제어 신호들로 확장시키는 방식, 연산 필드는 최소화
- 수평적 마이크로프로그래밍: 마이크로명령어들의 연산 필드에 필요한 제어신호 수만큼의 비트들을 포함, 각 비트를 제어신호로 직접 사용하는 방식



















