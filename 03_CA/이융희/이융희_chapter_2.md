컴퓨터 H/W 전반에 관한 내용

# 2. CPU의 구조와 기능
## 2.1 CPU의 기본 구조
**CPU의 기능**
```
-명령어 인출(Fetch) : 기억장치로부터 명령어를 읽어온다
-명령어 해독(Decode): 수행해야 할 동작을 경정하기 위하여 명령어를 해독한다
해독은 control unit(제어장치)가 수행한다, 모든 명령어에 수행
```
```
-데이터 인출 : 명령어 실행을 위하여 데이터가 필요한 경우 기억장치 혹은 I/O장치로
부터 그 데이터를 읽어온다
-데이터 처리 : 데이터에 대한 산술적 혹은 논리적 연산을 수행
-데이터 쓰기 : 수행한 결과를 저장
명령어에 따라 필요한 경우에만 수행
```


**CPU의 기본 구조**
- 산술논리연산장치(ALU)
- 레지스터 세트(Register Set)
- 제어 유니트(Control Unit)

**ALU**
산술 연산(사칙연산) 논리 연산(AND, OR, NOT, XOR등) 수행

**레지스터**
엑세스 속도가 가장 빠른 기억장치
CPU 내부에 포함할 수 있는 레지스터들의 수가 제한됨
(특수 목적용(CPU속 제어용), 일반 목적용(데이터가 저장되는 부분))

**제어 유니트**
프로그램 코드를 해석하고, 그것을 실행하기 위한 제어 신호들을 순차적으로
발생하는 하드웨어 모듈

**CPU 내부 버스**
ALU와 레지스터들 간의 데이터 선들과 제어 유니트로부터 발생되는 제어 신호 선들로 구성된 내부 버스


## 명령어 실행
**명령어 사이클**
CPU가 하나의 명령어를 실행하는 데 필요한 전체 처리 과정

**부사이클**
- 인출 사이클(fetch cycle) : CPU가 기억장치로부터 명령어를 읽어오는 단계
- 실행 사이클(execution cycle) : 명령어를 실행하는 단계

**특수 레지스터**
```
프로그램 카운터(PC) : 폰노이만 / 순차적으로 실행되기 위함
-다음에 인출할 명령어의 주소를 가지고 있는 레지스터
-각 명령어가 인출된 후에는 자동적으로 일정 크기(한 명령어 길이)만큼 증가
-분기(branch) 명령어가 실행되는 경우에는 목적지 주소로 갱신
```
```
누산기(AC)
-데이터를 일시적으로 저장하는 레지스터(ALU결과/입력)
-레지스터의 크기는 CPU가 한 번에 처리할 수 있는 데이터 비트 수
```
```
명령어 레지스터(IR)
-가장 최근에 인출된 명령어 코드가 저장되어 있는 레지스터
```

**CPU와 BUS사이의 레지스터**
```
기억장치 주소 레지스터(MAR)
-PC에 저장된 명령어 주소가 시스템 주소 버스로 출력되기 전에 일시적으로 저장되는 주소 레지스터
```
```
기억장치 버퍼 레지스터(MBR)
-기억장치에 쓰여질 데이터 혹은 기억장치로부터 읽혀진 데이터를 일시적으로 저장하는 버퍼 레지스터
```

### 2.2.1 인출 사이클
PC(메모리 주소) -> MAR -> 메모리/M[MAR] -> MBR -> IR (마이크로 연산)
ex) CPU 클록 = 1GHz(클록주기 = 1/1GHz)

### 2.2.2 실행 사이클
- CPU는 실행 사이클 동안에 명령어 코드를 해독(Decode)하고,그 결과에 따라 필요한 연산들을 수행

- CPU가 수행하는 연산들의 종류 : 데이터 이동, 처리, 저장, 제어 (마이크로-연산)

**기본적인 명령어 형식의 구성**

IR (operation code[CPU가 수행할 연산]/operand[데이터가 저장된 주소등])

ex1) LOAD addr 명령어 
IR(addr) -> MAR -> M[MAR] -> MBR -> AC
ex2) STA addr 명령어
IR(addr) -> MAR, AC -> MBR, MBR->M[MAR]  주소 찾고, 버퍼에 넣고, 메모리에 저장
ex3) ADD addr 명령어
IR(addr) -> MAR -> M[MAR] -> AC+MBR(ALU에서 더함) -> AC
ex4) JUMP addr 명령어
IR(addr) -> PC


## 2.2 명령어 실행, 명령어 파이프라이닝

- 인터럽트 사이클
**인터럽트**
```
프로그램 실행 중에 CPU의 현재 처리 순서를 중단시키고 다른 동작을 수행하도록 하는 시스템 동작
-외부로부터 인터럽트 요구가 들어오면 : 인터럽트부터 처리 후 원래의 수행 진행
-인터럽트 서비스 루틴(ISR) : 인터럽트를 처리하기 위하여 수행하는 프로그램 루틴 
```
**인터럽트 처리 과정**
```
어떤 장치가 인터럽트를 요구했는지 확인하고, 해당 ISR을 호출
1.현재의 명령어 실행을 끝낸 즉시, 다음에 실행할 명령어의 주소(PC의 내용)를 스택에 저장
-> 일반적으로 스택은 주기억장치의 특정 부분
2.ISR을 호출하기 위하여 그 루틴의 시작 주소를 PC를 적재
```

- 인터럽트 사이클
```
PC->MBR, SP->MAR, ISR의 시작 주소->PC, MBR->M(MAR), SP-1 -> SP(아래에서 위쪽)
```

- 다중 인터럽트
```
가능하면 인터럽트 우선 순위에 따라서 처리, SP에 차곡차곡 더 쌓음, PC값
불가능 하면 CPU 지속 수행
```

- 간접 사이클(C언어 포인터)
```
명령어에 포함되어 있는 주소를 이용하여, 그 명령어 실행에 필요한 데이터의 주소를 인출하는 사이클
```

## 2.3 명령어 파이프라이닝
*CPU의 프로그램 처리 속도를 높이기 위함*

**2-단계 명령어 파이프라인**
인출 단계(fetch)와 실행 단계(execute) : 2사이클 부터 동시에 두개를 실행하는 효과, 속도 두 배 향상
-첫 번째 클록 주기에서는 인출 단계
-두 번째 클로 주기에서는 실행 단계

**4-단계 명령어 파이프라인**
- 명령어 인출
- 명령어 해독
- 오퍼랜드 인출
- 실행 단계 (4사이클부터 4개 동시 실행)

**파이프라인 효율 저하 요인들**
- 파이프라인 단계들 모두 거치지 않을 경우
- IF단계, OF단계

## 2.3 명령어 파이프라인 문제점 : 해저드(Hazard)
*중앙처리장치의 마이크로 구조의 명령어 파이프라인에서 발생하는 문제로서 계산의 결과에 오류발생*

**3가지 종류의 해저드**
- 데이터 해저드 : 다른 단계의 데이터 충돌(의존성), 경쟁조건이 발생할 수 있다.
```
-read after write (RAW) : 데이터 해저드 발생 확률이 높음
참 종속성을 가지는 것은 원천적으로 해결하지 못함
NOP(no operation) 끼워 넣어 순서 구별?
순서를 의존성이 없는것과 바꿔서 문제해결(컴파일러가 의존성 체크하고 함)

-write after read (WAR) : 슈퍼스칼라, 2개 이상의 파이프라인일 때 발생가능
-write after write(WAW) : 슈퍼스칼라, 값을 동시에 쓸 때 문제
레지스터의 이름을 바꿔주면 문제가 되지 않음(레지스터 추가해야댐)
```

- 구조적 해저드
```
동시에 두 개 이상의 명령이 프로세서의 하드웨어 중 한 부분을 사용하려고 할 때 발생(ALU가 모자랄 때)
-메모리 장치를 분리(명령어 인출, 데이터 인출, 하버드 아키텍쳐(cf.폰 노이만 구조)), L1 cache 분리
-파이프라인에 버블을 끼워 넣는 방법

CPU 내의 장치에서 충돌이 생기는 경우
-ALU를 여러개 두는 방법
```

- 제어 해저드
```
분기가 발생할 때 일어난다. 미리 읽혀온 부분 폐기 해야됨(손해)
분기 예측(branch prediction)
-분기 역사 표 이용, 분기 목적지 선인출
-루프 버프 사용, 지연 분기(명령어 위치 재배치(컴파일러))
```

**해저드 처리 방법**
- 파이프라인 스톨(멈춤, 성능저하), 파이프라인 버블링(의미없는것 끼워넣음), 레지스터 포워딩등
- 비순서적인 실행(순서 바꿔 문제해결)

**상태 레지스터**
*조건 플래스들 저장*
-각종 상태를 플래그 값으로 저장(OS와 관련된 것도 있음)

## 2.3, 2.4 명령어 파이프라이닝, 명령어 세트
### 2.3.3 슈퍼스칼라
*두 개 이상의 파이프라인들을 포함시킨 구조*
```
해저드 때문에 실제 파이프라인 수만큼 향상 가능한것은 조금 틀린개념
```
- 속도 저하 (Sp < m) 요인
- 해결책 : 해저드 처리 방법과 동일

## 명령어세트(명령어 형식)
## 명령어세트(주소지정방식)
