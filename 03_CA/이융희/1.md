# 8. 고성능 컴퓨터시스템 구조
## 8.1 병렬처리의 개념 및 필요성
- 병렬처리 : divides and conquers, 다수의 프로세서로 여러 프로그램 또는 분할된 부분 동시 처리
- 병렬처리를 위한 선결 조건 : 여러 프로세스가 하나의 시스템을 구성할 수 있도록 작고 빨라야함
                          : 한 프로그램을 분할 가능해야 하며, 순차적 처리와 결과가 같아야함
- 야기되는 새로운 문제들 : 문제 분할 / 프로세서간 통신
- 필요한 관련 기술들
```
병렬 프로그램 언어와 컴파일러의 개발
상호 배타 메커니즘 지원
공유자원들에 대한 경합을 줄이고 이용률을 극대화할 수 있는 운영체제의 개발
```


## 8.2 병렬처리의 단위
- 작업-단위 병렬성 : 독립적인 작업 프로그램 단위로 병렬처리

- 태스크-단위 병렬성 : 큰 작업을 기능에 따라 분할 병렬처리(프로세서간 정보 교환 필요)

- 스레드-단위 병렬성 : 스레드 단위로 병렬처리(자바등 프로세스)

- 명령어-단위 병렬성 : 의존성이 없는 명령어를 병렬처리(궁극적 목표)


## 8.3 병렬컴퓨터의 분류
- Flynn의 분류 : 구조적 특징에 따른 분류
```
명령어 스트림 : 명령어가 쭉 흘러 들어오는것
데이터 스트림 : 데이터가 쭉 흘러 들어오는것
SISD : 단일 명령어 스트림 - 단일 데이터 스트림 = 단일 프로세서 시스템(파이프라이닝, 슈퍼스칼라 이용)
SIMD : 단일 명령어 스트림 - 복수 데이터 스트림 = 배열 프로세서(GPU), 하나의 제어 유니트로 여러 프로세싱 유닛 통제
MISD : 복수 명령어 스트림 - 단일 데이터 스트림 = N개의 프로세서에 서로 다른 명령어 실행 -> 비현실적(백업 컴퓨터 필요할 때)
MIMD : 복수 명령어 스트림 - 복수 데이터 스트림 = N개의 프로세서가 서로 다른 명령, 서로 다른 데이터 처리
     : 밀결합 시스템 : 공유-기억장치 구조, 다중 프로세서 시스템
     : 소결합 시스템 : local memory를 가진 독립적인 컴퓨터 모듈, 프로세서간 메세지 전송 방식, 다중 컴퓨터
```

- RISC : 하나의 명령어가 일을 적게하여 속도 향상, 싸서 사용함
- CISC : 하나의 명령어가 복잡(low-level 명령어 다수결합), 옛날꺼 또는 x86 intel, 모토롤라, 애플 
       : 다양한 요구 때문에 점점 명령어가 복잡해짐

- Memory Access Model에 따른 분류
```
균일 기억장치 엑세스(UMA) : 프로세서가 네트워크를 통해 누구나 기억장치로 엑세스 할 수 있게함(소요시간동일)
장점 : 하드웨어/프로그래밍 간단 / 단점 : 공유 자원 경합이 높아져 시스템 크기의 한계가 있음

불균일 기억장치 엑세스(NUMA) : UMA여러개 연결, 건너건너 다양하게 엑세스 하게됨
무-원격 기억장치 엑세스(NORMA) : 프로세서가 기억장치에 직접 엑세스 할 수 없는 구조(UMA->UMA만 불가능)
                             : UMA - UMA는 local memory에서 간접적으로 전달
```

**시스템 구성방법에 따른 분류**
```
대칭적 다중프로세서(SMP) : 64개 이하 프로세서, 시스템내 모든 자원 공유, 하나의 OS, 대칭적(직접 OS코드 수행, 동등한 프로세서 권한)
대규모 병렬프로세서(MPP) : 무공유 구조기반 대규모 병렬처리, 간단한 구조의 노드 프로세서(수백수천개), 커널OS, 메세지 전달 통신
캐쉬-일관성 NUMA 시스템(CC-NUMA) : UMA 혹은 NUMA가 상호연결망에 접속, 모든 기억장치들이 전역 주소공간을 가지는 분산 공유-기억장치시스템
                                : S/W 변경없이 SMP보다 더 큰 시스템 구축 가능함
분산 시스템(DS) : 독립적(local memory) 노드들이 TCP/IP등을 통해 연결
클러스터 컴퓨터(CC) : PC or workstations를 고속 랜, switch로 단일 시스템 이미지로 통합
                   : 장점 : 저렴하게 병렬처리시스템 구축가능, 결함 대체 용이(가용성)
```


## 8.4 다중프로세서시스템 구조, MIMD 여러 프로세서가 비동기적으로 프로그램 실행
- 기억장치 모듈을 사용하는(소유하는) 방식에 따른 분류
**공유-기억장치 시스템**
```
밀결합 구조로 주기억장치를 모든 프로세서에 공유

버스, 크로스바 스위치(배열, 고성능 소자필요), 다단계 상호연결망(2진 XOR로 브로드 캐스팅)

장점 : 프로세서간 데이터 교환 메커니즘 필요X, 프로세서 이용률 극대화
단점 : 연결에 경합이 발생, 공유자원 사용순서 때문에 느려짐
```

**분산-기억장치 시스템**
```
소결합 구조
각 프로세서가 자신의 local memory를 소유
다른 프로세서들과의 통신은 메시지 전송 이용
장점 : 공유자원에 대한 경합 감소 / 단점 : 통신 프로토콜에 의한 지연 시간 증가

분산기억장치 시스템에서의 상호연결망 구성방법
1.linear array구조 : 노드 수만큼 직렬로 연결됨(버스 보다 동시성 높음) 
2.ring 구조 : 단방향 N-1, 양방향 N/2 -> 코달 원형 : 노드에 링크(degree)를 추가 연결(네트워크 지름이 줄어듬)
3.tree 구조 : N = (2^k-1)개의 노드들 접속 k=level, 네트워크 지름 = 2(k-1), fat-tree(트리 줄기 증가, 병목현상 제거)
4.mesh network : 스위칭(array) 구조 -> torus network(소자 끝과 끝을 연결)
5.hypercube network : 큐브형태로 노드 연결, XOR로 가야하는 노드를 구함
```


## 8.5 클러스터 컴퓨터
*네트워크에 접속된 다수의 컴퓨터들을 통합하여 하나의 거대한 병렬 컴퓨팅 환경 구축*
- 개방형 클러스터 : 공공 네트워크로 노드를 접속하여 클러스터 외부 노출
```
-표준형이기 때문에 노드간 메시지 통신해야함
-다양한 통신 환경을 지원해야 하는 표준 프로토콜을 사용해야 하기 때문에, 통신 오버헤드가 상당히 ㅣ높다
-보안이 보장되지 못해 추가 보안 작업이 필요함
-국축하기 용이함(클러스터링을 위한 소프트웨어 탑재만 하면됨)
```

- 폐쇄형 클러스터 : 사설 네트워크를 사용하여 노드 접속, 외부 사용자 차단
```
-기억장치, 디스크, 메시지등으로 통신가능
-표준 프로토콜을 사용하지 않아 통신 오버헤드가 매우 낮아지며 프로토콜을 각 시스템에 맞게 효과적으로 구현가능
-통신 보안이 어느정도 보장됨
-외부 트래픽 영향이 없어 통신 지연이 줄어듬
-구현비용이 비교적 많이 들고, 외부 통신망과 접속은 한 노드를 통해서만 가능함
```

**단일 시스템 이미지(SSI)**
```
운영체제가 달라도 여러 컴퓨터들을 상호 연결하여 통합된 자원으로 사용될 수 있는 사용자 환경
OS와 프로그래밍 환경(도구)/응용 프로그램 사이에 위치하는 미들웨어 계층에 의해 지원
```

**미들웨어 S/W 하부구조**
```
SSI 인프라 : 똑같은 시스템인것처럼 보여주어 통합적으로 엑세스 가능하도록 지원해주는 클러스터의 핵심기술
      이점 : 어떤 노드에서 실행되고 있는지 알 필요 없게 해줌, 특정 자원 위치 알 필요 없게 해줌(필요한 경우 지원)
           : 중앙집중식, 분산식 둘 다 사용가능, 컴퓨터관리 단순화, 어느 노드에서든 시스템 관리 및 시스템 프로그래밍 가능

SA 인프라 : 클러스터에 부분적 결함이 발생해도 클러스터 컴퓨터가 계속 프로그램들을 처리할 수 있도록 해주는 기능
         : 체크포인트: 결함 발생 전에 백업, 자동페일오버: 노드결함 발생하면 다른 노드가 대신수행
         : 페일백 : 노드 결함이 복구되면 원래 노드로 작업수행 복원
```

## 8.6 슈퍼스칼라 구조
- Data hazards
- Structural hazards
- Branch(control) hazards
