# 7. 시스템 버스, I/O 및 인터럽트
## 7.1 시스템 버스
```
주소 버스(단방향) : 기억장치, 입출력장치, 비트 수에 따라 접속 가능한 기억장치 용량 결정됨
데이터 버스(양방향) : CPU, 메모리등 사이에 한번에 전송가능한 비트 수 만큼의 선이 있음
제어 버스(단방향-들어오고 나가는게 구별) : CPU, 기억장치, I/O장치 사이의 신호 전송
```

```
16bit 주소 버스 : 2^16 = 64K개, 바이트 단위 지정일 경우 64Kbyte
24bit : 2^24 = 16M, 바이트 단위 16Mbyte
```

**주요 제어 신호**
```
기억장치 쓰기
기억장치 읽기
입출력 쓰기
입출력 읽기
전송 확인 신호
```


## 7.2 버스 중재(통제)
**버스 연결 요소들이 버스를 사용하려할 때 충돌 방지**
버스 마스터 : 버스를 사용하려고 하는 주체(CPU, RAM등)
버스 중재 : 순서를 정해서 사용할 수 있게 해주는 동작

**중재 버스**
```
bus request 신호 : 사용하려 요구하는 신호
bus grant 신호 : 요구한 마스터에게 사용 허가하는 신호
bus busy : 버스가 사용중임을 나타내는 신호
```

**인터럽트 버스**
```
interrupt request 신호 : I/O 장치가 인터럽트를 요구
interrupt acknowledge 신호 : CPU가 인터럽트 요구를 인식
bus clock : 동기식 버스 동작의 시작 시간 싱크로용
reset : 모든 시스템 요소 동작을 초기화하는 신호
```

버스 대역폭 : 버스 속도의 척도로 단위 시간당 전송할 수 있는 데이터 양
ex) 클럭 20Mhz, 버스폭 8byte : 대역폭 = 버스폭 X 클럭 bps

**시스템 버스의 기본 동작**
```
쓰기 동작 : 버스 마스터가 버스 사용권 획득, 버스를 통해 주소와 데이터 및 쓰기 신호 전송
읽기 동작 : 버스 마스터가 버스 사용권 획득, 주소와 읽기 신호를 보내고 데이터 전송 기다림
```

**버스 분류**
```
동기식 버스 : 모든 버스 동작들이 공통의 버스 클럭을 기준으로 발생
장점 : 회로 간단, 클락 주기가 길면 안좋음
비동기식 버스 : 버스 동작들의 발생 시간이 관련된 다른 버스 동작의 발생 여부에 따라 결정(M/S 의존)
단점 : 낭비되는 CLK은 없지만 회로가 복잡하고 빠른 시스템에서 안좋음
```

**버스 중재 방식**
```
위치에 따른 분류
중앙집중식 중재 방식 : 모든 버스 요구를 하나의 중재기에서 통재
분산식 중재 방식 : 버스 마스터 마다 중재기 갖고 있어야 하며 컨트롤하기 어려움
```

*병렬 중재 방식 : 각 버스 마스터가 요구선을 각각 갖고 있어 요구 승인 신호가 각각 필요함*
```
1. 중앙집중식 고정우선순위 방식 : 모든 마스터가 접속 (가까울 수록 높은 우선순위(요청 AND로 연결 +1, +1 +2))
2. 분산식 고정우선순위 방식 : 모든 마스터가 중재기 하나씩 보유 BUSY 확인하고 사용시작, 회로 복잡
3. 가변우선순위 방식 : 중재 회로 복잡, (회전 우선순위)버스 사용 끝날 때마다 우선순위 -1 또는 최저 우선순위
-임의 우선순위 방식, 동등 우선순위 방식(FIFO), 최소-최근 사용 방식(오래 사용하지 않은 마스터에게 우선순위)
```

*직렬 중재 방식*
```
1. 중앙집중식 직렬 중재 방식 : (데이지-체인)하나의 선에 순서대로 요구한 마스터가 있을 경우 승인(USB)
2. 분산식 직렬 중재 방식 : 각 마스터마다 중재기 있다는 것만 다름, 중재기가 직렬로 연결
단점 : 한 지점만 결함이 발생해도 전체 시스템 동작 중단
```

*폴링방식 : 중재기가 마스터에게 주기적으로 일일이 물어봄*
```
1. 하드웨어 폴링 : 중재기, 마스터 간에 각각의 폴링선 존재(2진 폴링 주소 : logN개), 느리게 쓸 때 좋음
2. 소프트웨어 폴링 : 버스 중재기내의 프로세서가 관장하는 방식
단점 : 하드웨어에 비해 느림 / 장점 : 우선순위 변경이 유리
```


## 7.3 I/O 장치의 접속
### 7.3.1 I/O 제어
*제어 방법이 다르고 많아서 실제 시스템 버스 접속X, I/O 제어기(인터페이스)를 사용*
*CPU처리 속도랑 I/O장치 전송속도 차이가 커 직접 교환 불가능, 데이터 형식이 다름*

**I/O 제어기 주요 기능**
```
I/O 장치의 제어와 타이밍 조정
CPU, I/O 장치와 통신 담당
데이터 버퍼링 기능 수행
오류 검출
```

**I/O 주소지정**
```
장치를 file로 연결하여 주소로 지정(linux)
상태 레지스터 주소 : 장치 상태와 오류 검사 결과를 비트로 나타냄
제어 레지스터 주소 : CPU가 보낸 명령을 저장
-기억장치-사상 I/O : 기억장치 주소 영역 일부분을 I/O 제어 주소로 할당 / 프로그래밍 제어가능
-분리형 I/O : 따로 주소 저장하는 곳 사용 / 프로그래밍 불편, 기억장치 리소스 감소 없음
```

*프로그램을 이용한 I/O : CPU가 직접 검사 및 처리, 간단하지만 CPU 리소스소모*



## 7.4 인터럽트를 이용한 I/O : I/O동작 동안 CPU가 다른 작업을 처리할 수 있게 하는 방식
- 다중-인터럽트 방식 : 각각의 인터럽트 요구선으로 확인하고 통신하는 방법
장점 : 인터럽트 요구 마스터를 쉽게 찾을 수 있음 / 단점 : 복잡, CPU핀의 수로 제한됨

- 데이지-체인 방식(USB) : I/O제어기들 직렬 접속하여 인터럽트 전달(선 하나)
장점 : 하드웨어 간단 / 단점 : 우선순위 낮은 장치는 서비스를 오래 받지 못하는 경우 발생

- 소프트웨어 폴링 방식 : CPU가 일일이 물어보는 방식
장점 : 우선순위 변경 용이 / 단점 : 처리 시간이 오래 걸림


## 7.5 DMA(직접기억장치액세스)를 이용한 I/O
*CPU 개입 없이 기억장치와 I/O장치 데이터 전송하는 방식(사이클 훔침)*

**DMA 처리 순서**
```
1. CPU가 DMA 제어기에 명령 전송(I/O 주소, 연산 지정자, 주기억장치 주소, 단어 수)
2. DMA제어기는 CPU로 버스 요구 신호 전송
3. CPU가 DMA제어기로 버스 승인 신호 전송
4. DMA제어기가 주기억장치 데이터를 읽어 디스크 제어기에 저장
5. 전송완료까지 2~4 반복
6. 완료되면 CPU로 INTR 신호 전송
```
*문제점 : 데이터 전송 마다 버스를 두번씩사용(성능 저하) -> I/O버스 따로 두거나 DMA제어기 따루 둠*
*I/O 프로세서 사용(I/O채널)*

### IOP를 이용한 I/O : 고급 컴퓨터 or 입출력이 많이 필요할 때 사용

## 7.6 외부 버스
ATA(IDE) 하드하나, SATA 여러개, eSATA +외부연결, firewire(오디오/비디오)
USB 비대칭(serial->tree 변형된 데이지 체인, 여러 허브)

