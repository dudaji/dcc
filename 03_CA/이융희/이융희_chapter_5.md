# 5. 기억장치
## 5.1 기억장치 분류와 특성
**기억장치 엑세스**
```
CPU가 어떤 정보를 기억장치에 쓰거나 기억장치로부터 읽는 동작

1.순차적 엑세스 : 저장된 정보를 처음부터 순서대로 엑세스하는 방식 ex)자기 테이프
2.직접 엑세스 : 원하는 위치로 이동하여, 순차적 검색을 통해 최종 위치에 도달하는 방식
-FAT(실제 저장X, 기본적내용저장(테이블 이동)) ex)디스크, CD-ROM
-NTFS(윈도우), UFS(유닉스)
3.임의 엑세스 : 주소에 의해 직접 기억 장소를 찾아 엑세스(디코더 이용) ex) RAM, ROM
4.연관 엑세스 : 특정 비트를 비교하여 일치하는 내용을 엑세스 ex) 캐시
```

**기억장치 설계 / 전송단위 / 주소지정 단위**
```
설계요소 : 용량, 엑세스 속도, 가격
전송 단위 : CPU가 한 번의 기억장치 엑세스에 처리 가능한 비트 수 ((주)word, (보조)block)
주소지정 단위 : 보통 바이트 단위 혹은 word 단위
```

**엑세스 속도와 관련된 파라미터**
```
엑세스 시간 : 엑세스 시작부터 완료되는 순간까지의 시간  (한번에)
기억장치 사이클 시간 : 엑세스 시간 + 데이터 복원 시간
데이터 전송률 : (1/엑세스 시간) * (한 번에 읽혀지는 비트 수) bps
```

## 5.2 계층적 기억장치시스템
### 5.2.1 필요성 및 효과
```
계층 : 레지스터->캐시->메모리->usb->하드->테이프
```

```
필요성 : 속도, 용량, 가격

엑세스 속도 / 비트당 가격 비례
용량 / 비트당 가격 반비례
용량 / 엑세스 속도 반비례

효과 : 계층별로 비율조정하여 기억장치 시스템의 가성비 향상
```

**지역성의 원리**
```
기억장치 엑세스 시간이 단축됨
캐시에서 다시
```

**기억장치 계층**
```
내부 기억장치 : CPU가 직접 엑세스할 수 있는 기억장치, ex) CPU 레지스터, 캐시, RAM
외부 기억장치 : 직접 엑세스할 수 없고 제어기로할 수 있는 기억장치, ex) 디스크,CD-ROM
```

**캐시 기억장치 / 디스크 캐시**
```
캐시 기억장치 : CPU - RAM의 엑세스 속도 향상(CPU가 덜기다리게 됨)
디스크 캐시 : DISK - RAM의 엑세스 속도 차이를 줄이기 위하여
```

## 5.3 반도체 기억 장치
### 5.3.1 RAM : 읽기 / 쓰기
**메모리의 단위 : bit**
```
DRAM(Dynamic) : 주기억장치, capacity 전하축적 이용하기 떄문에 재충전 해야함
-집적도 높고 비교적 가격이 저렴함
SRAM(Static) : 캐시메모리 (flip-flop 안정회로)
-집적도 떨어지지만 빠르고 가격이 비쌈
```
```
64bit RAM 내부조직 : (3X8디코더)8(주소bit)X8(데이터bit)
                  : 16x4 (4x16디코더)
                  : 64x1 (3x8디코더 2개필요)
16M X 4 조직
4096x4096x4
주소 비트 12/12 필요(행열 주소 사용하기 떄문에 실제 주소선 12개사용)
```

### 5.3.2 ROM 읽기
*영구 저장이 가능한 반도체 기억장치*
*PC의 BIOS프로그램, 서브루틴(기본)에 사용*
```
PROM : 한번 쓰는 것 가능한 ROM
EPROM : 자외선으로 내용을 지울 수 있는 PROM, 여러번 쓰기가능
EEPROM : 전기적으로 지울 수 있는 EPROM, 데이터 갱신 횟수 제한
플레시 메모리 : 블록(64페이지) 단위로 삭제, 페이지 단위로 읽기/쓰기가 가능한 EEPROM
EEPROM보다 삭제시간빠르고(2ms), 직접 밀도도 더높다
```

**메모리의 구성 예**
```
1K(10bit 주소버스필요) x 8bit : 주소갯수 x 주소당 데이터수 <-> 데이터 버스(8bit)
CS(칩선택신호) 1, RD 1, WR(0) : 읽기 동작
4K x 4bit
```


## 5.4 기억장치 모듈의 설계
**워드길이 확장**
```
각 메모리 칩의 데이터의 길이가 원하는 데이터의 길이보다 작을 때
원하는 길이를 맞추어 설계 (칩 병렬연결(동시))
16진수(2진수 4bits)
```

**워드용량 확장**
```
메모리 칩의 주소공간이 부족할 떄 여러 개를 직렬(따로)로 연결하여 전체 주소공간을 확장
2^4 x 4 : 2개 일 때 2^5x4 에서 남는 한 bit는 칩 선택용(CS, CS')
```

**워드길이 및 워드용량 확장**
```
워드의 길이 및 워드의 용량이 모두 모자랄 떄 둘 다 확장하는 방법
```

**RAM과 ROM을 차례로 연결**
```
전체 주소 공간에서 둘을 모두 연결하여 사용할 때
ex) 8bit 마이크로컴퓨터 기억장치
256*4 : 1KByte RAM(0부터), 10bit : 1KByte ROMS(800H(1000)부터)
```


## 5.5 캐시 기억장치 SRAM
*사용 목적 : CPU와 주기억장치 속도 차이 개선*
*가격 및 제한된 공간 떄문에 용량이 적다*
**용어**
```
캐시 적중(cache hit) : CPU가 원하는 데이터가 (레지스터에 없을 때)캐시에 있는 상태
캐시 미스(cache miss): CPU가 원하는 데이터가 캐시에 없는 상태 -> RAM으로감
적중률(hit ratio) : H = 캐시 적중 횟수 / 전체 기억장치 엑세스 횟수
캐시의 미스율 : 1 - H
평균 기억장치 엑세스 시간(Ta) : Ta = H X Tc + (1 - H) X Tm
```

**지역성에 따라 성능이 좌우된다**
```
시간적 지역성 : 다시 엑세스 될 가능성 높다
공간적 지역성 : 메모리에 인접하여 저장되어 연속적으로 엑세스 될 가능성이 높다
순차적 지역성 : 분기가 발생하지 않는 한, 명령어들이 순서대로 인출된다
```

**캐시 설계의 공통적 목표**
```
1.캐시 적중률 극대화
2.캐시 엑세스 시간의 최소화
3.캐시 미스에 따른 지연 시간의 최소화
4.주기억장치와 캐시간의 데이터 일관성 유지(슈퍼컴퓨터) 및 그에 따른 오버헤드 최소화
일관성 : 캐시에서 바뀐걸 RAM에 갱신
```

**인출방식**
```
요구인출 : CPU가 필요할 때 CM <- MM
선인출 : 미리 연속되는 내용 인출(블록(라인)단위, 지역성 높은 경우 효과적)
태그 : 어떤 블록이 인출됬는지 표시
```

*캐시 사상 방식*
**직접사상**
```
여러개의 블록이 한개의 라인을 공유함, 한시점에 한라인당 한블록(tag로 블록 구분)
장점 : 하드웨어, 저렴
단점 : 히트율이 줄어듬
```

**완전-연관 사상**
*심플하지만 구현불가*
```
주기억장치 블록이 캐시의 어떤 라인으로든 적재 가능
line X, 모든 tag비교 해봐야함(line갯수 많아지면 안좋음)
장점 : 지역성에 매우 좋고, 라인 선택이 자유로움
단점 : 복잡한 하드웨어 필요, 시간증가
```

**세트-연관 사상**
*실제 시스템에서 사용하는 방식, 직접 + 완전*
```
tag / set / word 필드
세트연관 사상은 적중률을 어느 정도 향상시킬 수 있다.
```

**동작 원리**
```
한세트속에 두개 이상의 라인이 있음(공유) : tag를 세트당 라인수 만큼 비교

주기억장치 2^24바이트, 블록(4바이트) 2^22개
캐시 2^16바이트 , 라인(4바이트) 2^14개 / 2(2way) : set 13bit

태그 9 세트 13 단어 2
```

**캐시의 교체 알고리즘**
*세트-연관 사상에 해당*
```
주기억장치로부터 새로운 블록이 캐시로 적재될 때
만약 세트 내 모든 라인이 채워져 있다면, 어떤 블록을 교체할지
정하는 알고리즘
```

```
최소 최근 사용(LRU) 알고리즘 : 가장 오래 사용되지 않은 블록 교체
FIFO 알고리즘 : 가장 오래된 블록을 교체
최소 사용 빈도(LFU) 알고리즘 : 참조 횟수가 가장 적은 블록 교체
```

### 캐시의 쓰기 정책
```
캐시 블록이 변경되었을 때 그 내용을 주기억장치에 갱신하는 시기와 방법
1.Write through : 모든 쓰기 동작들이 캐시, 주기억장치에 동시 수행
장점 : 내용이 둘 다 항상 같다
단점 : 쓰기 시간이 길어진다, 연산하는 동안 가져가면 공유 문제 발생

2.Write back : 캐시에서 데이터가 변경되어도 주기억장치에서는 갱신X(블록교체할 때 생신)
장점 : 쓰기 동작 횟수 감소, 쓰기 시간 짧아짐
단점 : 내용이 서로 다를 수 있다.(일관성 유지X : 다중프로세서의 병렬처리에서 공유 문제)
```

**다중캐시 속도 L1 > L2 > L3 > MM**
*온-칩 캐시 : CPU칩내 캐시(엑세스 시간 단축 L1)
```
계층적캐시 : L2는 L1의 슈퍼-세트, L2에는 L1의 모든 내용이 존재

분리캐시 : L1(명령어, 데이터) = 파이프라인(명령어 인출 유니트 / 실행 유니트) 충돌 방지용
```

## 5.6 최신 기억장치 기술

