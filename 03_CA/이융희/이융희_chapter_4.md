# 4. 제어 유니트
## 4.1 제어 유니트의 기능
*명령어 코드의 해독*
*명령어 실행에 필요한 제어 신호들의 발생*
**1.Hardwired control(변경불가)**

**2.소프트웨어로 control**
```
마이크로명령어 : 명령어 사이클의 각 주기에서 실행되는 마이크로-연산들에 대응되는 비트들로
이루어진 단어로서, 제어 단어라고도 함
마이크로프로그램 : 마이크로명령어들의 집합
루틴 : CPU의 특정 기능을 수행하기 위한 마이크로명령어들의 그룹
```

## 4.2 제어 유니트의 구조
**구성 요소들**
```
명령어 해독기 : IR의 OPCODE를 해독하여 루틴의 시작주소를 결정
제어 주소 레지스터(CAR) : 제어 메모리 값 임시저장 -> MAR에 주소보낼 때 쓰임
제어 기억장치 : 마이크로명령어들로 이루어진 마이크로프로그램 저장(ROM-바뀌면 안됨)
제어 버퍼 레지스터(CBR) : 제어 기억장치로부터 읽혀진 명령어 임시저장 -> 해독기로 신호발생
서브루틴 레지스터(SBR) : 서브루틴 호출될 때 CAR 임시저장
순서제어 모듈 : 마이크로명령어의 실행 순서를 결정하는 회로들의 집합
```

**CPU의 명령어 세트 설계 과정**
```
1. 명령어들의 종류와 비트 패턴 정의
2. 명령어들의 실행에 필요한 하드웨어 설계
3. 각 명령어를 위한 실행 사이클 루틴 작성(마이크로프로그래밍)
4. 마이크로프로그램 코드들을 제어 기억장치(CPU)에 저장
```

**명령어 해독**
```
사상(mapping)을 이용한 해독 방법
-opcode를 제어 메모리속 시작주소와 mapping, ex) 0001 -> 1000100
```

## 4.3 마이크로 명령어의 형식
```
연산 필드 두 개(마이크로-연산 동시 수행가능) 3bit : None, MAR <- PC, M[MAR] <- MBR등

조건(CD)필드는 분기에 사용될 조건 플래그를 지정, (간접 사이클 또는 값에 따른 분기 조건등)

분기(BR)필드는 분기의 종류와 다음에 실행할 마이크로명령어의 주소를 결정하는 방법을 명시
-분기 동작을 지정, 분기/JUMP/CALL, RED(서브루틴 복귀 SBR->CAR), MAP 1XXXX001 (opcode)

주소 필드(ADF)의 내용은 분기가 발생하는 경우에 목적지 마이크로 명령어의 주소로 사용
-JUMP/CALL일때 먼저 불렷다가 다음 CAR+1실행
```

## 4.4 마이크로 프로그래밍
### 4.4.1 인출 사이클 루틴의 마이크로명령어 루틴
```
FETCH(시작주소) PCTAR       : MAR <- PC
               READ, INCPC : BR <- M[MAR], PC = PC + 1
               BRTIR       : IR <- MBR, 해당 실행 사이클 루틴으로 분기 
```

### 4.4.2 간접 사이클 루틴
```
INDRT : IRTAR로 PC만 IR(addr)로만 바뀜
```

### 4.4.3 실행 사이클 루틴
```
사상(mapping)을 이용하여 opcode의 실행 사이클 루틴의 시작 주소 결정
시작주소 : 1(opcode(4bit))00
NOP, LOAD, STORE, ADD, SUB, JUMP등
제어 유닛에 실행사이클 ADD와 같은 명령어 만들어 넣는것
```

## 4.5 마이크로프로그램의 순서 제어
**순서제어 : 다음에 실행항 마이크로명령어 주소 결정**
```
CAR 초기값 = 0, 인출 사이클 루틴의 첫 주소
MUX1: 다음에 실행할 주소 선택
00 - CAR 1씩증가
01 - ADF
10 - SBR(서브루틴)
11 - 실행루틴(ADD등등)

MUX2: 조건 플래그를 선택하여 주소선택 회로로 전송
00 - 무조건 점프
01 - INDRT
10 - 음수일 때 어디로갈지
11 - AC내용이 0이면 Z = 0, 어디로 점프하라
```

**주소 선택 방법**
```
BR = 00(JUMP), 01(CALL)일 때
- C = 0, 다음 위치의 마이크로명령어 선택, C = 1, ADF로 점프 혹은 CALL
BR = 10(RET), CAR <- SBR 적재 복귀, BR = 11 mapping결과를 CAR에 적재
```

**제어 신호의 생성**
```
제어 기억장치로부터 인출된 마이크로명령어 내 연산 필드의 비트들이
제어 유니트의 외부로 출력되어, 각각 제어 신호로 사용됨
```

**수직적 마이크로프로그래밍**
```
연산 필드에 코드화된 비트로 만듬 3bit -> 8가지, 3*8디코더로 만들어 제어 신호들 확장
장점 : 제어 기억장치 용량 최소화
단점 : 해독에 딜레이 발생(추가 하드웨어 필요)
```

**수평적 마이크로프로그래밍**
```
디코더 없이 비트와 제어 신호를 1:1로 대응시키는 방식
장점 : 지연시간이 없음
단점 : 제어 기억장치 용량이 증가
```