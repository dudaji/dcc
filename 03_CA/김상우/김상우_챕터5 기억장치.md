# 챕터 5 기억장치

------------

## 5.1 기억장치의 분류와 특성

- 기억장치 엑세스 유형

  - 순차적 액세스 - 처음 부터 시작하여 순서대로 지나야한다.

  - 직접 액세스- 레코드 단위로 이동 후 순차적 검색으로 최종위치에 도달한다.

  - 임의 액세스 - 주소를 가지며 순차적이지 않고 임의적으로 엑세스 한다.

  - 연관 액세스 - key 값을 통해 엑세스 한다.

- 엑세스 속도 관련 파라미터

  - 엑세스 시간 - 주기억장치의 데이터를 CPU로 가져오는 시간 (CPU -> 주기억장치 -> CPU)
  - 기억장치 사이클 시간
  - 데이터 전송률 - 초당 읽/쓰여지는 비트 수



## 5.2 계층적 기억장치 시스템

- 기억장치들의 유형에 따라 기능, 속도, 용량 및 가격이 다양함
- 여러 유형의 기억장치를 계층적으로 설치한다.
- 필요성과 효과
  - 속도가 빠른 기억장치일수록 가격이 높다. 때문에 기억장치 설계에 가성비를 고려해야한다.
- 지역성 원리 - 한정된 위치에서 저장된 데이터만 주로 엑세스하면서 작업을 수행하는 특징
- 기억장치 계층
  - CPU 레지스터
  - 캐시
  - 주기억장치
  - SSD, HDD
  - CD-ROM



## 5.3 반도체 기억장치

- RAM

  - DRAM - 축전기에 저장하는 기억장치
  - <축전기>
  - ![ê·¸ë¦¼ â¡-14 ì¬ë¬ ê°ì§ ì¶ì ê¸°](http://t1.daumcdn.net/thumb/R659x0/?fname=http%3A%2F%2Ft1.daumcdn.net%2Fencyclop%2Fm24%2F7gR7hTUSwrqsEmpNANTqCcotsRDv2nbggCNlRS6s%3Ft%3D1463562830000)
  - [![그림 Ⅱ-15 평행판 축전기](http://t1.daumcdn.net/thumb/R659x0/?fname=http%3A%2F%2Ft1.daumcdn.net%2Fencyclop%2Fm24%2FvSV2SwyFS8BPlKpg4Li4NGBuVpNn1TEvLKu8EPJP%3Ft%3D1463562830000)](http://igoindol.net/siteagent/100.daum.net/multimedia/24_C-E-S3O-F0-0201-00005_002.jpg)
  - ![img](https://upload.wikimedia.org/wikipedia/commons/thumb/d/d3/RAM_n.jpg/280px-RAM_n.jpg)
  -  SRAM -플리플롭을 사용, SRAM이 더 빠르다. 캐쉬로 사용.
  - 8x8 비트 조작 - 8개의 기억소자들을 8 비트 씩 저장
  - 64x1 비트 조작 - 주소 비트들을 두 그룹으로 나누어 별도로 해독,
  - 16Mx4 비트 조작 - 4096 x 4096개의 행과 열로 구성, RAS, CAS에 레치 되어 데이터를 가져온다.

- ROM

  - PROM
  - EPROM
  - EEPROM
  - 플래시 메모리



## 5.4 기억장치 모듈의 설계

- 병렬 접속 - 여러 칩들에 데이터가 나누어져 동일한 주소로 배정된다. 쓰기 읽기 동작이 한번에 수행된다.
- 직렬 접속 - 하나의 칩에 데이터를 배정 받음
- 병렬 직렬을 조합하여 더큰 기억장치를 만듬



## 5.5 캐시 메모리

- 주기억장치 엑세스 속도는 CPU의 속도보다 현저히 느리다.

- 캐시 적중률 - $H=\frac{캐시에 적중되는 횟수}{전체 기억장치 액세스 횟수}​$ 

- 지역성
  - 시간적 지역성 - 최근에 엑세스된 명령어나 데이터가 가까운 미래에 다시 사용됨
  - 공간적 지역성 - 서로 인접한 데이터가 엑세스될 가능성이 높음
  - 순차적 지역성 - 명령어들이 기억장치에 저장된 순서대로 인출되어 실행될 가능성이 높음

- 캐시 용량 - 가격이 비쌈, 용량이 커질수록 주변회로가 복잡해짐

- 캐시 인출 방식 

  - 근접한 위치에 있는 정보들을 함께 인출하여 캐시에 적재
  - 지역성에 의해 역속적으로 액세스될 가능성이 높음
  - 태그가 저장되어 있어 어디에 적재되어 있는지 구분 가능

- 매핑 방식

  - 직접 사상
  - 완전 연관 사상
  - 세트 연관 사상

- 교체 알고리즘 - LRU, FIFO 등등

- 쓰기 정책

  - 캐시만 변경하고 주기억장치를 변경하지 않는다면?
  - 주기억장치와 캐시 모두 갱신해줘야한다. -> 갱신시 속도 문제
  - 교체 알고리즘에 의해 다른 블록으로 교체될 때 modified된 내용을 주기억장치에 적재 후 교체시킨다.

- 다중 캐시

  - 캐쉬도 L1, L2 여러개 나누어 계층적 기억장치로 구성

  - 명령어 캐쉬와 데이터 캐시로 분리하여 용도 구분



## 5.6 DDR SDRAM

- SDRAM - 동기식 DRAM, 속도 한계 극복, 시스템 클록에 맞춰 동기화가 수행된다.
- DDR SDRAM 
  - 상승엣지, 하강엣지 모두 전송하여 한클럭당 2번 전송하는 기법
  - 기억장치 제어기, 버스 회로 개선, 클록 주파수를 높인다.
  - DDR2는 두배 높은 클록 주파수를 사용했다는 의미
- 메모리 랭크
- 차세대 비휘발성 메모리



질문

왜 기억장치 모듈은 행렬로 구성하는가?

cache friendly code



const int ARR_MAX = 10000;
int tmp [ ARR_MAX] [ARR_MAX];

```c++
int main()
{
	ios_base::sync_with_stdio(false); cin.tie(NULL);
	clock_t begin, end;
	begin = clock();


    for (int i = 0; i < ARR_MAX; i++)
        for (int j = 0; j < ARR_MAX; j++)
            tmp[i][j] = 0;

    end = clock();

    cout << "수행시간 : " << (float)(end- begin) / CLOCKS_PER_SEC << endl;
    return 0;

}
```



tmp[i] [j] 를 tmp [j] [i] 로 실행해보세요.

매핑방식?

