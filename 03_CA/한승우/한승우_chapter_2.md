# 2. CPU의 구조와 기능

#### CPU의 기능

- 명령어 인출 : 기억장치로부터 명령어를 읽어온다.
- 명령어 해독 : 수행해야 할 동작을 결정하기 위해 명령어를 해독

> 모든 명령어들에 대하여 공통적으로 수행

- 데이터 인출 : 기억장치 혹은 I/O 장치로부터 그 데이터를 읽어옴
- 데이터 처리 : 데이터에 대한 산술적 혹은 논리적 연산을 수행
- 데이터 쓰기 : 수행한 결과를 저장

> 명령어에 따라 필요한 경우에만 수행

### 2.1 CPU의 기본 구조

- 산술논리연산장치 (ALU)
- 레지스터 세트
- 제어 유니트

**CPU의 내부 구성요소**

- ALU
  - 각종 산술 연산들과 논리 연산들을 수행하는 회로들로 이루어진 하드웨어 모듈
  - 산술 연산
  - 논리 연산
- 레지스터
  - 액세스 속도가 가장 빠른 기억장치
  - CPU 내부에 포함될 수 있는 레지스터들의 수가 제한됨
- 제어 유니트
  - 프로그램 코드(명령어)를 해석하고, 실행하기 위한 제어 신호들을 순차적으로 발생하는 하드웨어 모듈
- CPU 내부 버스
  - ALU 와 레지스터들 간 데이터 이동을 위한 데이터 선들과 제어 유니트로부터 발생되는 제어 신호 선들로 구성된 내부 버스

### 2.2 명령어 실행

##### 명령어 사이클

- CPU가 하나의 명령어를 실행하는데 필요한 전체 처리 과정

- 부사이클
  - 인출 사이클 : CPU가 기억장치로부터 명령어를 읽어오는 단계
  - 실행 사이클 : 명령어를 실행하는 단계

**명령어 실행에 필요한 CPU 내부 레지스터들**

- 프로그램 카운터(PC)
  - 다음에 인출할 명령어의 주소를 가지고 있는 레지스터
  - 각 명령어가 인출된 후에는 자동적으로 일정 크기만큼 증가
  - 분기 명령어가 실행되는 경우에는 목적지 주소로 갱신
- 누산기(AC)
  - 데이터를 일시적으로 저장하는 레지스터
  - 레지스터의 크기는 CPU가 한 번에 처리할 수 있는 데이터 비트 수
- 명령어 레지스터(IR)
  - 가장 최근에 인출된 명령어 코드가 저장되어 있는 레지스터
- 기억장치 주소 레지스터 (MAR)
  - PC에 저장된 명령어 주소가 시스템 주소 버스로 출력되기 전에 일시적으로 저장되는 주소 레지스터
- 기억장치 버퍼 레지스터 (MBR)
  - 기억장치에 쓰여질 데이터 혹은 기억장치로부터 읽혀진 데이터를 일시적으로 저장하는 버퍼 레지스터

#### 인출 사이클

- 메모리 속에있는 명령어를 읽어서 CPU 속으로 가져온다.

- 인출 사이클의 마이크로 연산
- t0 : MAR <- PC
  - 현재 PC 내용을 CPU 내부 버스를 통하여 MAR로 전송
- t1 : MBR <- M[MAR], PC <- PC + 1
  - 그 주소가 지정하는 기억장치 위치로부터 읽혀진 명령어가 데이터 버스를 통하여 MBR로 적재되며, PC의 내용에 1을 더한다
- t2 : IR <- MBR
  - MBR에 있는 명령어 코드가 명령어 레지스터인 IR로 이동

- CPU 클록 = 1GHz
  - 인출 사이클 -> 1ns * 3 = 3ns 소요

#### 실행 사이클

- CPU는 실행 사이클 동안 명령어 코드를 해독하고, 그 결과에 따라 필요한 연산들을 수행
- CPU가 수행하는 연산들의 종류
  - 데이터 이동
  - 데이터 처리
  - 데이터 저장
  - 프로그램 제어

**기본적인 명령어 형식의 구성**

- 연산 코드
  - CPU가 수행할 연산을 지정
- 오퍼랜드
  - 명령어 실행에 필요한 데이터가 저장된 주소

- 사례 1 LOAD addr 명령어
  - 기억장치에 저장되어 있는 데이터를 CPU 내부 레지스터인 AC로 이동하는 명령어
  - t0 : MAR <- IR(addr)
    - 명령어 레지스터 IR에 있는 명령어의 주소 부분을 MAR로 전송
  - t1 : MBR <- M[MAR]
    - 그 주소가 지정한 기억장소로부터 데이터를 인출하여 MBR로 전송
  - t2 : AC <- MBR
    - 그 데이터를 AC에 적재
- 사례 2 STA addr 명령어
  - AC 레지스터의 내용을 기억장치에 저장하는 명령어
  - t0 : MAR <- IR(addr)
    - 데이터를 저장할 기억장치의 주소를 MAR로 전송
  - t1 : MBR <- AC
    - 저장할 데이터를 버퍼 레지스터인 MBR로 이동
  - t2 : M[MAR] <- MBR
    - MBR의 내용을 MAR이 지정하는 기억장소에 저장
- 사례3 ADD addr 명령어
  - 기억장치에 저장된 데이터를 AC의 내용과 더하고, 그 결과는 다시 AC에 저장하는 명령어
  - t0 : MAR <- IR(addr)
    - 데이터를 저장할 기억장치의 주소를 MAR로 전송
  - t1 : MBR <- M[MAR]
    - 저장할 데이터를 버퍼 레지스터인 MBR로 이동
  - t2 : AC <- AC + MBR
    - 그 데이터와 AC의 내용을 더하고 결과값을 다시 AC에 저장
- 사례 4 JUMP addr 명령어
  - 오퍼랜드가 가리키는 위치의 명령어로 실행 순서를 변경하는 분기 명령어
  - t0 : PC <- IR(addr)
  - 명령어의 오퍼랜드가 PC에 저장
  - 다음 명령어 인출 사이클에서 그 주소의 명령어가 인출되므로 분기가 발생

###  2.2.3 인터럽트 사이클

**인터럽트**

- 프로그램 실행 중에 CPU의 현재 처리 순서를 중단시키고 다른 동작을 수행하도록 하는 시스템 동작
- 외부로부터 인터럽트 요구 들어오면
  - CPU는 원래 프로그램 수행 중단하고
  - 요구된 인터럽트를 위한 서비스 프로그램을 먼저 수행

**인터럽트 서비스 루틴**

- 인터러트를 처리하기 위하여 수행하는 프로그램 루틴

**인터럽트 처리 과정**

- 인터럽트 들어왔을 때 CPU는
  - 어떤 장치가 인터럽트를 요구했는지 확인하고, 해당 ISR 호출
  - 서비스가 종료된 다음에는 중단되었던 원래 프로그램의 수행 계속
- CPU 인터럽트 처리의 세부 동작
  - 현재의 명령어 실행을 끝낸 즉시, 다음에 실행할 명령어의 주소 PC의 내용을 스택에 저장
  - ISR을 호출하기 위해 그 루틴의 시작 주소를 PC에 적재
  - 이때 실행 주소는 인터럽트를 요구한 장치로부터 전송되거나 미리 정해진 값으로 결정

#### 인터럽트 사이클의 마이크로 연산

- t0 : MBR <- PC
  - PC의 내용이 MBR로 전송
- t1 : MAR <- SP, PC <- ISR의 시작 주소
  - SP의 내용이 MAR로 전송되고, PC의 내용은 인터럽트 서비스 루틴의 시작 주소로 변경
- t2 : M[MAR] <- MBR , SP <- SP - 1
  - MBR에 저장되어 있던 원래 PC의 내용이 스택에 저장

#### 다중 인터럽트

- 인터럽트 서비스 루틴을 수행하는 동안에 다른 인터럽트 발생

**다중 인터럽트의 처리방법**

- 인터럽트의 우선 순위를 정하고, 우선 순위가 낮은 인터럽트가 처리되고 있는동안에 우선순위가 더 높은 인터럽트가 들어오면 현재의 인터럽트 서비스 루틴의 수행을 중단하고 새로운 인터럽트를 처리

### 2.2.4 간접 사이클

- 명령어에 포함되어 있는 주소를 이용하여, 그 명령어 실행에 필요한 데이터의 주소를 인출하는 사이클
  - 간접 주소지정 방식에서 사용
- 인출 사이클과 실행 사이클 사이에 위치
- t0 : MAR <- IR(addr)
- t1 : MBR <- M[MAR]
- t2 : IR(addr) <- MBR

### 2.3 명령어 파이프라이닝

- CPU의 프로그램 처리 속도를 높이기 위해 CPU 내부 하드웨어를 여러 단계로 나누어 동시에 처리하는 기술

**2단계 명령어 파이프라인**

- 명령어를 실행하는 하드웨어를 인출 단계와 실행 단계라는 두 개의 독립적인 파이프라인 모듈로 분리
- 두 단계들에 동일한 클록을 가하여 동작 시간을 일치
- 명령어 처리 속도가 두 배 향상
- 문제점
  - 두 단계의 처리 시간이 동일하지 않으면 두배의 속도 향상 얻지 못함
  - 해결책
    - 파이프라인 단계의 수를 증가시켜 각 단계의 처리 시간을 같게 함

**4단계 명령어 파이프라인**

- 명령어 인출 단계
- 명령어 해독 단계
- 오퍼랜드 인출 단계
- 실행 단계

**파이프라인의 효율 저하 요인들**

- 모든 명령어들이 파이프라인 단계들을 모두 거치지는 않는다
  - 어떤 명령어에서는 오퍼랜드를 인출할 필요가 없다.
- 파이프라인의 클록은 처리 시간이 가장 오래 걸리는 단계를 기준으로 결정된다
- IF 단계와 OF 단계가 동시에 기억장치를 액세스 하는경우에 기억장치 충돌이 일어나면 지연이 발생한다.
- 조건 분기 명령어가 실행되면, 미리 인출하여 처리하던 명령어들이 무효화된다.

#### 해저드

- 중앙처리장치의 마이크로 구조의 명령어 파이프라인에서 발생하는 문제, 잠재적으로 게산의 결과에 오류가 발생하는 것
- 데이터 해저드
- 구조적 해저드
- 제어 해저드 또는 분기 해저드
- 해저드 처리 방법
  - 파이프라인 스톨, 파이프라인 버블링, 레지스터포워딩

**데이터 해저드**

- 파이프라인의 서로 다른 단계에서 수정이 필요한 데이터끼리 의존성이 존재할 때 발생
- 잠재적인 데이터 해저드 무시하면 경쟁조건이 발생할 수 있음
- 발생가능한 상황
  - read after write
  - write after read
  - write after write

**Read After Write**

- 두개의 명령 i1,i2 있을 때, 프로그램의 순서상 i1이 i2보다 앞에 있다고 가정
- i1이 어떤값 저장하기 전에 i2가 그 값 읽으려고 시도
- 앞 명령의 연산이 끝나지 않았거나 값을 가져오기 전에 뒤에 명령에서 그 데이터를 사용하려고 하는 경우 발생

**Write After Read**

- i1이 읽어가기 전에 i2가 목적지에 저장하려고 하는 경우
- 동시 실행으로 인하여 발생하는 문제
- i1이 사용하기 전에 i2가 완료되는 경우에 발생하는 상황

**Write After Write**

- i1이 저장하기 이전에 i2가 저장하려고 하는 경우
- 동시 실행 환경에서 발생할 수 있다.
- i1이 실행이 완료될 때 까지 i2는 데이터 저장을 대기하고 있어야 함

**데이터 해저드 해결 방법**

- RAW : 참 종속
  - 참 종속성을 가지므로 원천적으로 해결 못함
  - 파이프라인에 NOP(no operation)을 끼워 넣는 방법 사용
  - 명령어 재배치
- WAR,WAW
  - Register renaming(레지스터 이름 바꾸어 줌)
  - 하드웨어적인 방법이나 컴파일러가 바꿔줌
  - 여분의 레지스터가 있어야함

**구조적 해저드**

- 두 개 이상의 명령어 프로세서의 하드웨어 중 한 부분을 사용하려고 할 때 발생

**구조적 해저드 해결 방법**

- 명령어 인출과 데이터 인출이 동시에 발생
  - 메모리 장치를 분리하거나 분리 캐시를 사용하는 방법
  - 메모리 자체를 분리하는 경우 : 하버드 아키텍쳐
  - 파이프라인에 버블을 끼워 넣는 방법
- CPU 내의 장치에서 충돌이 생기는 경우
  - 추가적으로 장치를 여러 개 둠

**제어 해저드(분기 해저드)**

- 분기가 발생할 때 일어남

**분기 발생에 의한 성능 정하의 최소화 방법**

- 분기 예측
  - 분기 역사 표를 이용하여 최근의 분기 결과 참조
- 분기 목적지 선인출
  - 조건 분기가 인식되면, 분기명령어의 다음 명령어 뿐만아니라 분기의 목적지 명령어도 함께 인출하는 방법
- 루프 버퍼 사용
  - 가장 최근 인출된 n개의 명령어들을 순서대로 루프 버퍼에 저장해둠
- 지연 분기
  - 분기 명령어의 위치를 재배치

**상태 레지스터**

- 족너분기 명령어가 사용할 조건 플래그들 저장
- 부호(S) 플래그
  - 직전에 수행된 산술연산 결과값의 부호 비트를 저장
- 영(Z) 플래그
  - 연산 결과값이 0 이면, 1
- 올림수(C) 플래그
  - 덧셈이나 뺄셈에서 올림수나 빌림수가 발생한 경우에 1로 세트

- 동등(E) 플래그
  - 두 수를 비교한 결과가 같게 나왔을 경우에 1로 세트
- 오버플로우(V) 플래그
- 인터럽트(I) 플래그
- 슈퍼바이저(P) 플래그

**슈퍼스칼라**

- CPU의 처리속도 높이기 위해 내부에 두 개 혹은 그 이상 명령어 파이프라인들을 포함시킨구조
- 매 클록 주기마다 각 명령어 파이프라인이 별도의 명령어를 인출하여 동시에 실행할 수 있기 때문에, 이론적으로 프로그램 처리 속도가 파이프라인 수만큼 향상 가능
- 슈퍼스칼라의 속도 저하 요인
  - 동시 실행 가능한 명령어 수 < m
  - 해결책
    - 명령어 실행 순서 재배치
    - 하드웨어 추가 설치

### 2.3.4 듀얼코어 및 멀티코어

- CPU 코어
  - 명령어 실행에 필요한 CPU 내부의 핵심 하드웨어 모듈
- 멀티코어 프로세서
  - 여러 개의 CPU 코어들을 하나의 칩에 포함시킨 프로세서
- 칩 레벨 다중프로세서 or 단일 칩 다중프로세서 라고도 부름

- 각 CPU 코어는 별도의 H/W 모듈로 이루어지며, 시스템 버스와 캐시만 공유
- 프로그램 실행에 있어서 각 코어는 더 높은 독립성 가짐
  - 멀티 태스킹
  - 멀티 스레딩

### 2.4 명령어 세트

- 어떤 CPU를 위해 정의되어 있는 명령어들의 집합
- 명령어 세트 설계를 위해 결정되어야 할 사항들
  - 연산 종류
    - CPU가 수행할 연산들의 수 와 종류 및 복잡도
  - 데이터 형태
    - 연산에 수행할 데이터들의 형태, 데이터의 길이, 수의 표현 방식
  - 명령어 형식
    - 명령어의 길이, 오퍼랜드 필드들의 수와 길이
  - 주소지정 방식
    - 오퍼랜드의 주소를 지정하는 방식

### 2.4.1 연산의 종류

- 데이터 전송
  - 레지스터와 레지스터 간, 레지스터와 기억장치 간, 혹은 기억장치와 기억장치 간 데이터를 이동하는 동작
- 산술 연산
- 논리 연산
- 입출력
- 프로그램 제어

**서브루틴 호출을 위한 명령어들**

- CALL 명령어
  - 현재의 PC 내용을 스택에 저장하고 서브루틴의 시작 주소로 분기하는 명령어
- RET 명령어
  - CPU가 원래 실행하던 프로그램으로 복귀시키는 명령어

**CALL/RET 명령어의 마이크로 연산**

- CALL X 명령어에 대한 마이크로-연산
- t0 : MBR <- PC
- t1 : MAR <- SP, PC <- X
- t2 : M[MAR] <- MBR, SP<- SP -1

- RET 명령어의 마이크로-연산
  - t0 : SP<- SP + 1
  - t1 : MAR <- SP
  - t2 : PC <- M[MAR]

### 2.4.2 명령어 형식

**명령어의 구성요소들**

- 연산 코드
  - 수행될 연산을 지정
- 오퍼랜드
  - 연산을 수행하는 데 필요한 데이터 혹은 데이터의 주소
  - 각 연산은 한 개 혹은 두 개의 입력 오퍼랜드들과 한 개의 결과 오퍼랜드를 포함
- 다음 명령어 주소
  - 현재의 명령어 실행이 완료된 후에 다음 명령어를 인출할 위치 지정

**명령어 형식**

- 필드
  - 명령어가 각 구성 요소들에 소요되는 비트들의 그룹
- 명령어 형식
  - 명령이 내 필드들의 수와 배치 방식 및 각 필드의 비트 수
- 명령어의 길이
  - 단어 길이

**명령어 형식의 결정에서 고려할 사항들**

- 연산 코드 필드 길이 : 연산의 개수를 결정
- 오퍼랜드 필드의 길이 : 오퍼랜드의 범위 결정

**오퍼랜드 수에 따른 명령어 분류**

- 1주소 명령어
  - 오퍼랜드를 한 개만 포함하는 명령어
  - ADD X ; AC <- AC + M[X]
- 2주소 명령어
  - 두 개의 오퍼랜드를 포함하는 명령어
  - ADD R1, R2 ; R1 <- R1 + R2
- 3주소 명령어
  - 세 개의 오퍼랜드들을 포함하는 명령어
  - ADD R1,R2,R3 ; R1 <- R2 + R3

### 2.4.3 주소지정 방식

- 다양한 주소지정 방식 사용하는 이유
  - 제한된 수의 명령어 비트들을 이용하여 사용자로 하여금 여러 가지 방법으로 오퍼랜드를 지정하고 더 큰 용량의 기억장치를 사용할 수 있도록 하기 위함
- EA : 유효 주소, 데이터가 저장된 기억장치의 실제 주소
- A : 명령어 내의 주소 필드 내용
- R : 명령어 내의 레지스터 번호
- (A) : 기억장치 A 번지의 내용
- (R) : 레지스터 R의 내용

**직접 주소지정 방식**

- 오퍼랜드 필드의 내용이 유효 주소가 되는 방식
- 장점 : 데이터 인출을 위해 한 번의 기억장치 액세스만필요
- 단점 : 연산 코드를 제외하고 남은 비트들만 주소 비트로 사용될 수 있기 때문에 직접 지정할 수 있는 기억장소의 수가 제한

**간접 주소지정 방식**

- 오퍼랜드 필드에 기억장치 주소가 저장되어 있지만, 그 주소가 가리키는 기억 장소에 데이터의 유효 주소가 저장되어 있도록 하는 방식
- EA = (A)
- 장점 : 최대 기억장치용량의 단어의 길이에 의해 결정 -> 확장 가능
- 단점 : 실행 사이클 동안 두 번의 기억장치 액세스 필요
  - 처음 액세스는 주소를 읽어 오기 위한 것
- 명령어 형식에서 간접비트 필요

**묵시적 주소지정 방식**

- 명령어 실행에 필요한 데이터의 위치가 묵시적으로 지정되는 방식
- SHL 명령어 : 누산기의 내용을 좌측으로 쉬프트
- PUSH R1 명령어 : 레지스터 R1의 내용을 스택에 저장
- 장점 : 명령어 길이가 짧다
- 단점 : 종류가 제한된다

**즉치 주소지정 방식**

- 데이터가 명령어에 포함되어 있는 방식
- 용도 : 프로그램에서 레지스터들이나 변수의 초기 값을 어떤 상수값으로 세트하는데 유용하게 사용
- 장점 : 데이터를 인출하기 위해 기억장치를 액세스할 필요가 없음
- 단점 : 상수값의 크기가 오퍼랜드 필드의 비트 수에 의해 제한

**레지스터 주소지정 방식**

- 연산에 사용할 데이터가 레지스터에 저장되어 있는 방식
- EA = R
- 주소지정에 사용될 수 있는 레지스터들의 수 = 2 의 k 승 개 
- 장점 : 오퍼랜드 필드의 비트 수가 적어도 된다, 데이터 인출을 위해 기억장치 액세스가 필요 없다
- 단점 : 데이터가 저장될 수 있는 공간이 CPU 내부 레지스터들로 제한

**레지스터 간접 주소지정 방식**

- 오퍼랜드 필드가 가리키는 레지스터의 내용을 유효 주소로 사용하여 실제 데이터를 인출하는 방식
- 장점 : 주소지정 할 수 있는 기억장치 영역이 확장

**변위 주소지정 방식**

- 직접 주소지정과 레지스터 간접 주소지정 방식의 조합
- EA = A + (R)
- 사용되는 레지스터에 따라 여러 종류의 변위 주소지정 방식 정의

**상대 주소지정 방식**

- 프로그램 카운터를 레지스터로 사용
- EA = A + (PC)
- 장점 : 일반적인 분기 명령어보다 적은 수의 비트만 있으면 됨
- 단점 : 분기 범위가 오퍼랜드 필드의 길이에 의하여 제한

**인덱스 주소지정 방식**

- 인덱스 레지스터의 내용과 변위 A를 더하여 유효 주소를 결정
- EA = (IX) + A
- 주요 용도 : 배열 데이터 액세스
- 자동 인덱싱
  - 명령어가 실행될 때마다 인덱스 레지스터의 내용이 자동적으로 증가 혹은 감소
  - 이 방식이 사용된 명령어가 실행되면 두 연산이 연속적으로 수행됨
    - EA = (IX) + A
    - IX <- IX + 1

**베이스-레지스터 주소지정 방식**

- 베이스 레지스터의 내용과 변위 A를 더하여 유효 주소를 결정
- EA = (BR) + A
- 서로 다른 세그먼트내 프로그램의 위치 지정

### 2.4.4 실제 상용 프로세서들의 명령어 형식

**PDP-10 프로세서**

- 고정 길이의 명령어 형식 사용
  - 단어의 길이 = 36비트, 명령어의 길이 = 36비트
  - 연산 코드 = 9비트, 최대 512 종류의 연산 허용

**PDP-11 프로세서**

- 다양한 길이의 명령어 형식들 사용
  - 연산 코드 : 4~ 16비트
  - 주소 개수 : 0,1,2개 

**펜티엄 프로세서의 명령어 형식**

- 즉치 방식
- 레지스터 방식
- 변위 방식
- 베이스 방식
- 상대 방식